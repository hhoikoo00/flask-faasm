import hashlib
import logging
from base64 import b64encode
from pathlib import Path
from typing import Any

import requests
from faasmtools.endpoints import get_faasm_invoke_host_port, get_faasm_upload_host_port  # type: ignore

from lib.constants import CPYTHON_FUNC, CPYTHON_USER, CPYTHON_WASM_FILE

logger = logging.getLogger(__name__)


UPLOAD_HOST, UPLOAD_PORT = get_faasm_upload_host_port()  # type: ignore
INVOKE_HOST, INVOKE_PORT = get_faasm_invoke_host_port()  # type: ignore
FAASM_OUTPUT_TEXT_SEP = "Python call succeeded\n\n"


def upload_func(wasm_file_path: Path, user: str, fn_name: str) -> None:
    """
    Upload a C/C++ function compiled in WASM to Faasm.

    Arguments:
        * `wasm_file_path`: Path for the WASM binary file to upload.
        * `user`: User Identifier for function in Faasm.
        * `fn_name`: Function Identifier in Faasm.
    """

    upload_url = f"http://{UPLOAD_HOST}:{UPLOAD_PORT}/f/{user}/{fn_name}"

    # Upload the function to Faasm.
    logger.info(f"Uploading function '{user}/{fn_name}' to {upload_url!r}...")
    with open(wasm_file_path, "rb") as wasm_file:
        res = requests.put(upload_url, data=wasm_file)

    # Handle error if the upload request fails.
    res.raise_for_status()

    logger.info("Upload successful!")
    logger.debug(f"Upload response: {res.text!r}")


def upload_cpython_runtime() -> None:
    """Convenience function for uploading a CPython runtime compiled in WASM."""
    upload_func(CPYTHON_WASM_FILE, CPYTHON_USER, CPYTHON_FUNC)


def upload_py_func(source: str, fn_name: str | None = None) -> str:
    """
    Upload a python function to WASM.

    Arguments:
        * `source`: String source code of the Python function/script to upload.
                    Source usually obtained from `inspect.getsource()` or from a .py file.
        * `fn_name`: Function identifier in Faasm.
                     If None provided, name is generated from a SHA256 hash of the source.

    Returns:
        Function identifier for the uploaded function. Mainly useful if ID generated by this function.
    """

    # Provide a default function name if none provided. Use the hash code of function's source.
    if fn_name is None:
        fn_name = hashlib.sha256(source.encode()).hexdigest()[:32]

    upload_url = f"http://{UPLOAD_HOST}:{UPLOAD_PORT}/p/python/{fn_name}"

    # Upload the Python function to Faasm.
    logger.info(f"Uploading Python function {fn_name!r} to {upload_url!r}...")
    res = requests.put(upload_url, data=source)

    # Handle error if the upload request fails.
    res.raise_for_status()

    logger.info("Upload successful!")
    logger.debug(f"Upload response: {res.text!r}")

    return fn_name


def encode_input(input_data: str) -> str:
    """Encode the given `input_data` into Base 64 for uploading to Faasm."""

    # The input data field must be base64 encoded.
    return b64encode(input_data.encode(encoding="utf-8")).decode(encoding="utf-8")


def extract_output(result_text: str) -> str:
    """Extract the output generated by Faasm function from the `write_output()` function."""

    _, output = result_text.split(FAASM_OUTPUT_TEXT_SEP, maxsplit=1)
    return output


def invoke_py_func(fn_name: str, input_data: str | None = None) -> Any:
    """
    Invoke the uploaded Python function on Faasm.

    Arguments:
        * `fn_name`: Function Identifier in Faasm for the function to invoke.
        * `input_data`: Input data to pass to the function, if needed. Must be a string so that it could be encoded.

    Returns:
        The output of the function generated by `write_output()`.
    """

    # Prepare invoke data.
    invoke_data = {
        "async": False,
        "user": "python",
        "function": "py_func",
        "python": True,
        "py_user": "python",
        "py_func": fn_name,
    }

    # Encode and include input data if input data provided.
    if input_data is not None:
        invoke_data["input_data"] = encode_input(input_data)

    invoke_url = f"http://{INVOKE_HOST}:{INVOKE_PORT}"

    # Invoke the uploaded function.
    logger.info(f"Invoking Python function {fn_name!r} with arguments: ({input_data!r})...")
    res = requests.post(invoke_url, json=invoke_data)

    # Handle error if the invoke request fails.
    res.raise_for_status()

    logger.info("Invoke successful!")
    logger.debug(f"Invoke Response [{res.status_code}]: {res.text!r}")

    output = extract_output(res.text)

    return output
